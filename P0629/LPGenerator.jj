options{
    STATIC=false;
}

PARSER_BEGIN(LPGenerator)
import java.util.*;
import java.io.*;

public class LPGenerator{
    public static Obj getProgram(String filename)throws ParseException{
	Reader reader=null;
	Obj p=null;
	try{
	    reader=new FileReader(filename);
	    p=new LPGenerator(reader).programf();
	}catch(FileNotFoundException e){
	    System.out.println(filename+" is not found");
	}
	return p;
    }
    public static Obj getProgramFromString(String s)throws ParseException{
	Reader reader=new StringReader(s);
	Obj p=null;
	reader=new StringReader(s);
	p=new LPGenerator(reader).programf();
	return p;
    }
}
PARSER_END(LPGenerator)

SKIP:{<[" ","\t","\r","\n"]>}
SKIP:{<("#" (~["\n","\r"])* ("\n"|"\r\n"|"\r")?)>}

TOKEN:{
    <IF:"if">
    |<ELSE:"else">
    |<WHILE:"while">
    |<FORALL:"forall">
    |<EXISTS:"exists">
    |<IN:"in">
    |<FOR:"for">
    |<FUN:"fun">
    |<MINIMIZE:"minimize">
    |<MAXIMIZE:"maximize">
    |<LIBRARY:"library">
    |<VARIABLE:"variable"|"free"|"generalfree"|"general"|"binary">
    |<NUMBER:"number">
    |<DEF:"def">
    |<SUBJECT:"subject">
    |<VAR:"var">
    |<IMPORT:"import">
    |<INTEGER:(["0"-"9"])+>
    |<DOUBLE:(["0"-"9"])+"."(["0"-"9"])+>
    |<IDENTIFIER:("@")?["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","_","0"-"9"])*>
}

Obj  programf():
{
    Obj obj;
    List<Obj> list=new ArrayList<Obj>();
    Token t,t2;
    List<String> libs=new ArrayList<String>();
}
{
    (<IMPORT> t2=<IDENTIFIER>{libs.add(t2.image);})* (t=<LIBRARY>|t=<MINIMIZE>|t=<MAXIMIZE>)(obj=stmtf(){list.add(obj);})*<EOF>
    {
	return new Program(libs,t.image,list);
    }
}

Obj stmtf():
{
    Obj cond,init,step,stmt,stmt2=null,params,expr,expr2,expr3;
    List<Obj> stmts;
    Token t,t2;
}
{
    ";"
    {
	return new IntObj(1);
    }
    |LOOKAHEAD(<IF> "(")
    <IF> "(" cond=exprf() ")" [":"] stmt=stmtf() [LOOKAHEAD(1) <ELSE> [":"] stmt2=stmtf()]
    {
	if(stmt2==null)return new IfStmt(cond,stmt);
	return new IfStmt(cond,stmt,stmt2);
    }
    |<IF> cond=exprf() (":" stmt=stmtf() | stmt=blockstmtf()) [LOOKAHEAD(1) <ELSE> [":"] stmt2=stmtf()]
    {
	if(stmt2==null)return new IfStmt(cond,stmt);
	return new IfStmt(cond,stmt,stmt2);
    }
    |<WHILE> "(" cond=exprf() ")" stmt=stmtf()
    {
	return new WhileStmt(cond,stmt);
    }
    |
    <FOR> 
    (
    "(" init=exprf() ";" cond=exprf() ";" step=exprf() ")" stmt=stmtf()
    {
	return new ForStmt(init,cond,step,stmt);
    }
    |t=<IDENTIFIER> <IN> expr=exprf() stmt=nestedforeachstmtf()
    {
	return new ForEachStmt(new Identifier(t.image),expr,stmt);
    }
    )
    |<DEF> t=<IDENTIFIER> "(" params=paramsf() ")" stmt=stmtf()
    {
	return new FuncDefStmt(t.image,params,stmt);
    }
    |
    <SUBJECT> ("{" expr=subjsf() "}"|expr=argsf() ";")
    {
	return new FuncCall(new Identifier("subject"),expr);
    }
    |LOOKAHEAD("{") stmt=blockstmtf()
    {
	return stmt;
    }
    |LOOKAHEAD(<VARIABLE> "{")
    t=<VARIABLE> "{" {stmts=new ArrayList<Obj>();} (t2=<IDENTIFIER> ";"{stmts.add(new LPDefStmt(t.image,t2.image));})*
    "}"
    {
	return new BlockStmt(stmts);
    }
    |t=<VARIABLE> t2=<IDENTIFIER> ";"
    {
	return new LPDefStmt(t.image,t2.image);
    }
    |stmt=exprf() ";"
    {
	return stmt;
    }
}
Obj subjsf():
{
    List<Obj> subjs=new ArrayList<Obj>();
    Obj expr;
}
{
    (expr=exprf(){subjs.add(expr);} ";")+
    {
	return new Args(subjs);
    }
}
Obj blockstmtf():
{
    List<Obj> stmts;
    Obj stmt;
}
{
    "{" {stmts=new ArrayList<Obj>();} (stmt=stmtf(){stmts.add(stmt);})* "}"
    {
	return new BlockStmt(stmts);
    }
}

Obj nestedforeachstmtf():
{
    Obj list,stmt;
    Token t;
}
{
    "," t=<IDENTIFIER> <IN> list=exprf() stmt=nestedforeachstmtf()
    {
	return new ForEachStmt(new Identifier(t.image),list,stmt);
    }
    |":" stmt=stmtf()
    {
	return stmt;
    }
    |stmt=blockstmtf()
    {
	return stmt;
    }
}
Obj paramsf():
{
    List<Obj> params=new ArrayList<Obj>();
    Token t;
}
{
    [t=<IDENTIFIER>{params.add(new Identifier(t.image));}]("," t=<IDENTIFIER>{params.add(new Identifier(t.image));})*
    {
	return new Params(params);
    }
}
Obj exprf():
{
   Obj expr;
}
{
    expr=expr9f()
    {
	return expr;
    }
}

Obj expr9f():
{
    Token index;
    Obj list,expr,option=null;
}
{
    <FORALL> index=<IDENTIFIER> <IN> list=exprf() expr=nestedforallf()
    {
	return new ForAll(new Identifier(index.image),list,expr);
    }
    |LOOKAHEAD(2) <EXISTS> "(" option=exprf() ")" index=<IDENTIFIER> <IN> list=exprf() expr=nestedexists2f()
    {
	return new Exists(new Identifier(index.image),list,expr,option);
    }
    |<EXISTS> index=<IDENTIFIER> <IN> list=exprf() expr=nestedexistsf()
    {
	return new Exists(new Identifier(index.image),list,expr);
    }
    |expr=expr8f()
    {
	return expr;
    }
}

Obj expr8f():
{
    Obj left,right;
}
{
    left=expr7_5f() 
    [LOOKAHEAD(2)("=" right=exprf(){left=new BinOp("=",left,right);}
    |"+=" right=exprf(){left=new BinOp("=",left,new BinOp("+",left,right));}
    |"-=" right=exprf(){left=new BinOp("=",left,new BinOp("-",left,right));}
    |"*=" right=exprf(){left=new BinOp("=",left,new BinOp("*",left,right));}
    |"/=" right=exprf(){left=new BinOp("=",left,new BinOp("/",left,right));}
    )]
    {
	return left;
    }
}

Obj expr7_5f():
{
    Obj expr,then=null,elze;
}
{
    expr=expr7f() [LOOKAHEAD(1)"?" then=exprf() ":" elze=expr7_5f(){expr=new Cond(expr,then,elze);}]
    {
	return expr;
    }
}
Obj expr7f():
{
    Obj left,right;
}
{
    left=expr6f() ["->" right=exprf(){left=new BinOp("->",left,right);}]
    {
	return left;
    }
}

Obj expr6f():
{
    Obj left,right;
}
{
    left=expr5f() ("||" right=expr5f(){left=new BinOp("||",left,right);})*
    {
	return left;
    }
}

Obj expr5f():
{
    Obj left,right;
}
{
    left=expr4f() ("&&" right=expr4f(){left=new BinOp("&&",left,right);})*
    {
	return left;
    }
}

Obj expr4f():
{
    Obj left,right;
    Token op;
}
{
    left=expr3f()
    [(op=">="|op="<="|op=">"|op="<"|op="=="|op="!=")right=expr3f()
    {
	left=new BinOp(op.image,left,right);
    }]
    {
	return left;
    }
}

Obj expr3f():
{
    Obj left,right;
    Token op;
}
{
    left=expr2f() ((op="+"|op="-")right=expr2f(){left=new BinOp(op.image,left,right);})*
    {
	return left;
    }
}

Obj expr2f():
{
    Obj left,right;
    Token op;
}
{
    left=unaryf() (
    (op="*"|op="//"|op="/"|op="%")right=unaryf()
    {
	left=new BinOp(op.image,left,right);
    })*
    {
	return left;
    }
}

Obj unaryf():
{
    Obj expr,list;
    Token op,index;
}
{
    
    (op="-"|op="+"|op="!") expr=unaryf()
    {
	return new Unary(op.image,expr);
    }
    |expr=postfixf()
    {
	return expr;
    }
}


Obj nestedforallf():
{
    Token index;
    Obj list,expr;
}
{
    "," index=<IDENTIFIER> <IN> list=exprf() expr=nestedforallf()
    {
	return new ForAll(new Identifier(index.image),list,expr);
    }
    |":" expr=exprf()
    {
	return expr;
    }
}

Obj nestedexistsf():
{
    Token index;
    Obj list,expr;
}
{
    "," index=<IDENTIFIER> <IN> list=exprf() expr=nestedexistsf()
    {
	return new Exists(new Identifier(index.image),list,expr);
    }
    |":" expr=exprf()
    {
	return expr;
    }
}

Obj nestedexists2f():
{
    Token index;
    Obj list,expr;
}
{
    "," index=<IDENTIFIER> <IN> list=exprf() expr=nestedexistsf()
    {
	return new Exists(new Identifier(index.image),list,expr,true);
    }
    |":" expr=exprf()
    {
	return expr;
    }
}

Obj postfixf():
{
    Obj expr,args,index;
}
{
    expr=primaryf() ("(" args=argsf() ")" {expr=new FuncCall(expr,args);}
    |"[" index=exprf() "]" {expr=new ListRef(expr,index);})*
    {
	return expr;
    }
}

Obj argsf():
{
    ArrayList<Obj> args=new ArrayList<Obj>();
    Obj expr;
}
{
    [expr=exprf(){args.add(expr);}]("," expr=exprf(){args.add(expr);})*
    {
	return new Args(args);
    }
}

Obj primaryf():
{
    Token t;
    Obj expr,params,block;
    List<Obj> elements;
}
{
    t=<INTEGER>
    {
	return new IntObj(Integer.parseInt(t.image));
    }
    |t=<DOUBLE>
    {
	return new DoubleObj(Double.parseDouble(t.image));
    }
    |<VAR> t=<IDENTIFIER>
    {
	return new Identifier(t.image,true);
    }
    |t=<IDENTIFIER>
    {
	return new Identifier(t.image);
    }
    |"(" expr=exprf() ")"
    {
	return expr;
    }
    |<FUN> "(" params=paramsf() ")" block=stmtf()
    {
	return new Lambda(params,block);
    }
    |"[" {elements=new ArrayList<Obj>();} [expr=exprf(){elements.add(expr);} ("," expr=exprf(){
	elements.add(expr);})*]"]"
    {
	return new ObjList(elements);
    }
}
